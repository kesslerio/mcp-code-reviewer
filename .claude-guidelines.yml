# Claude Code Architectural Guidelines for Anti-Pattern Coach
# Compatible with proposed Claude Code guideline enforcement (GitHub Issue #427)
# Enhanced with anti-pattern prevention and educational content

name: "Anti-Pattern Prevention Guidelines"
description: "Prevent systematic engineering failures through architectural guideline enforcement"
enforcement: "explain"  # Our unique educational enforcement mode

# Standard Claude Code compatible guidelines
guidelines:
  - id: "infrastructure-without-implementation"
    description: "Detect custom solutions when standard APIs exist"
    pattern:
      language: "python"
      ast_match: "class.*Client|def.*request|def.*fetch"
    enforcement: "warn"
    files:
      include: ["src/**/*.py", "lib/**/*.py"]
      exclude: ["tests/**", "docs/**"]
    
  - id: "symptom-driven-development"
    description: "Identify fixes targeting symptoms vs root causes"
    pattern:
      language: "python"
      ast_match: "cache|Cache|redis|Redis|memcache"
    enforcement: "warn"
    files:
      include: ["src/**/*.py"]
    
  - id: "complexity-escalation"
    description: "Flag unnecessary complexity introductions"
    pattern:
      language: "python"
      ast_match: "microservice|distributed|queue|Queue"
    enforcement: "warn"
    files:
      include: ["src/**/*.py"]
      
  - id: "documentation-neglect"
    description: "Ensure documentation research before custom implementation"
    pattern:
      language: "python"
      ast_match: "TODO.*doc|FIXME.*doc|# need.*doc"
    enforcement: "strict"
    files:
      include: ["src/**/*.py"]

# Anti-Pattern Coach extensions (our specialized additions)
anti_patterns:
  - id: "infrastructure-without-implementation"
    case_study: "docs/case_studies/cognee_integration_failure.md"
    educational_content:
      why_problematic: |
        Building custom HTTP clients and infrastructure before testing standard APIs
        leads to 2+ years of technical debt and zero working functionality.
        The Cognee integration failed because we built custom HTTP servers
        instead of using cognee.add() → cognee.cognify() → cognee.search().
      examples:
        - "examples/antipatterns/custom_http_client.py"
        - "examples/antipatterns/premature_infrastructure.py"
      alternatives:
        - "Research official SDKs first (stripe-python, boto3, etc.)"
        - "Test basic integration with 10-line proof of concept"
        - "Document why standard approach is insufficient before custom build"
        - "Use cognee.add() → cognee.cognify() → cognee.search() pattern"
    prevention_checklist:
      - "Have you researched the official SDK/API documentation?"
      - "Have you tested a basic integration (< 10 lines of code)?"
      - "Can you document 3 specific limitations of the standard approach?"
      - "Have you validated that custom infrastructure is truly necessary?"
    confidence_threshold: 0.8
    
  - id: "symptom-driven-development"
    case_study: "docs/case_studies/performance_symptom_fixes.md"
    educational_content:
      why_problematic: |
        Adding caching, queues, or performance optimizations without identifying
        root causes leads to complex systems that don't solve actual problems.
        Symptom fixes create technical debt and mask underlying issues.
      examples:
        - "examples/antipatterns/premature_caching.py"
        - "examples/antipatterns/queue_overengineering.py"
      alternatives:
        - "Profile and measure before optimizing"
        - "Fix database queries before adding caching"
        - "Optimize algorithms before adding infrastructure"
        - "Use built-in monitoring to identify actual bottlenecks"
    prevention_checklist:
      - "Have you identified the root cause with profiling/monitoring?"
      - "Have you tried fixing the underlying issue first?"
      - "Can you measure the actual performance impact?"
      - "Will this solution address the root cause or just symptoms?"
    confidence_threshold: 0.75

  - id: "complexity-escalation"
    case_study: "docs/case_studies/microservice_overengineering.md"
    educational_content:
      why_problematic: |
        Introducing microservices, distributed systems, or complex architectures
        for simple problems creates unnecessary operational overhead and
        maintenance burden without corresponding benefits.
      examples:
        - "examples/antipatterns/premature_microservices.py"
        - "examples/antipatterns/unnecessary_distribution.py"
      alternatives:
        - "Start with monolithic approach for validation"
        - "Scale vertically before scaling horizontally"
        - "Use proven solutions (Postgres) before exotic tech"
        - "Add complexity only when simple solutions demonstrably fail"
    prevention_checklist:
      - "Have you tried the simplest possible solution first?"
      - "Can you justify the complexity with specific requirements?"
      - "Do you have operational expertise for the complex solution?"
      - "Will the complexity solve a current problem vs. theoretical future need?"
    confidence_threshold: 0.7

  - id: "documentation-neglect"
    case_study: "docs/case_studies/documentation_research_failures.md"
    educational_content:
      why_problematic: |
        Building custom solutions without thoroughly researching official
        documentation leads to reinventing solved problems and missing
        established patterns that could save weeks of development time.
      examples:
        - "examples/antipatterns/undocumented_custom_solution.py"
        - "examples/antipatterns/ignored_official_patterns.py"
      alternatives:
        - "Read official documentation completely before building"
        - "Search for 'getting started' and 'best practices' guides"
        - "Look for official examples and sample code"
        - "Check GitHub issues for common integration patterns"
    prevention_checklist:
      - "Have you read the complete official documentation?"
      - "Have you found and reviewed official examples?"
      - "Have you searched for community best practices?"
      - "Can you explain why the documented approach won't work?"
    confidence_threshold: 0.8

# Integration settings for Anti-Pattern Coach
integration:
  claude_code_compatible: true
  educational_mode: true
  case_study_links: true
  prevention_checklists: true
  confidence_scoring: true
  
# Output configuration
output:
  format: "educational"  # educational, json, claude-code-standard
  include_examples: true
  include_alternatives: true
  include_case_studies: true
  confidence_threshold_display: true